(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
Clear@myEquations
myEquations[initialconditions:{x0_,y0_,z0_,\[Theta]0_,\[Psi]0_,V0_},gammafun_,nyfun_,nxfun_,t0_:0]:=With[

{g=9.81,
t0rule={t->t-t0} (* for correcting domains of resulting InterpolationFunctions *)},

{
(* equations of motion *)
(nxfun/.t0rule)-Sin[\[Theta][t]]==V'[t]/g,
(nyfun Cos[gammafun]/.t0rule)-Cos[\[Theta][t]]==V[t]/g  \[Theta]'[t],
(nyfun Sin[gammafun]/.t0rule)==V [t]Cos[\[Theta][t]]/g (-\[Psi]'[t]),

(* kinematic relationships, which may be considered as a part of Eqs of M. *)
x'[t]==V[t]Cos[\[Theta][t]]Cos[\[Psi][t]],
y'[t]==V[t] Sin[\[Theta][t]],
z'[t]==-V[t] Sin[\[Psi][t]]Cos[\[Theta][t]],

(* initial conditions *)
x[t0]==x0,y[t0]==y0,z[t0]==z0,
\[Theta][t0]==\[Theta]0,  \[Psi][t0]==\[Psi]0,V[t0]==V0
}
]

myEquations[___]:=$Failed


(* ::Input::Initialization:: *)
Clear@manevrQ
manevrQ[arg_]:=MatchQ[arg,{Rule__}]


(* ::Input::Initialization:: *)
ClearAll@domain
domain[intfun_InterpolatingFunction]:=First@(intfun["Domain"])
domain[manevrresult_?manevrQ]:=domain[manevrresult[[1,1]]/.manevrresult]
domain[___]:=$Failed


(* ::Input::Initialization:: *)
ClearAll@tStart
tStart[manevrresult_?manevrQ]:=First@domain@manevrresult
tStart[___]:=$Failed


(* ::Input::Initialization:: *)
ClearAll@tFinal
tFinal[manevrresult_?manevrQ]:=Last@domain@manevrresult
tFinal[___]:=$Failed


(* ::Input::Initialization:: *)
ClearAll@lastState
lastState[manevrresult_?manevrQ]:=
Through[({x,y,z,\[Theta],\[Psi],V}/.manevrresult)[tFinal[manevrresult]]]
lastState[___]:=$Failed


(* ::Input::Initialization:: *)
Clear@initialConditionsQ
initialConditionsQ[arg_]:=MatchQ[arg,{__?NumericQ}]&&Length[arg]==6


(* ::Input::Initialization:: *)
ClearAll@maneuver
(*maneuver::msg1="1";
maneuver::msg2="2";*)

maneuver[initialconditions_?initialConditionsQ,gammafun_,nyfun_,nxfun_,event_,t0_:0]:=((*Message[maneuver::msg1];*)First@Quiet[NDSolve[
myEquations[initialconditions,gammafun,nyfun,nxfun,t0]~Join~{WhenEvent[event,{"StopIntegration"}]},
{V,\[Theta],\[Psi],x,y,z},
{t,t0,Infinity}
],{NDSolve::ihist}])

maneuver[prevmaneuver_?manevrQ,gammafun_,nyfun_,nxfun_,event_]:=((*Message[maneuver::msg2];*)maneuver[lastState@prevmaneuver,gammafun,nyfun,nxfun,event,tFinal@prevmaneuver])

maneuver[___]:=$Failed


(* ::Input::Initialization:: *)
ClearAll@trajectoryPlot
trajectoryPlot[manevrresult_?manevrQ]:=ParametricPlot3D[#[t]&/@({x,y,z}/.manevrresult),{t,0,tFinal[manevrresult]},PlotRange->Full,AxesLabel->{"x","y","z"},PlotStyle->Thickness[0.0075]]
trajectoryPlot[___]:=$Failed


(* ::Input::Initialization:: *)
Clear@inequality
inequality[domain_]:=First@domain<=t<=Last@domain


(* ::Input::Initialization:: *)
Clear@joinInterpolatingFunctionPiecewise
joinInterpolatingFunctionPiecewise[args:{InterpolatingFunction__}]:=Piecewise[MapThread[List,{#[t]&/@args,inequality/@(domain/@args)}]]


(* ::Input::Initialization:: *)
(*
How to splice together several instances of InterpolatingFunction?

http://mathematica.stackexchange.com/questions/19042/how-to-splice-together-several-instances-of-interpolatingfunction
*)
Clear@joinInterpolatingFunction
joinInterpolatingFunction[intervals_List,flist_List]:=Module[{getGrid},getGrid[f_InterpolatingFunction,min_?NumericQ,max_?NumericQ]:={{min,f[min]}}~Join~(Transpose@{f["Grid"]//Flatten,f["ValuesOnGrid"]}//Select[#,(min<#[[1]]<max)&]&)~Join~{{max,f[max]}}//N;
Interpolation[Table[getGrid[flist[[i]],intervals[[i]],intervals[[i+1]]],{i,Length@flist}]//Flatten[#,1]&//DeleteDuplicates[#,(#1[[1]]==#2[[1]])&]&,InterpolationOrder->1]]


(* ::Input::Initialization:: *)
functionslist={V,\[Theta],\[Psi],x,y,z};


(* ::Input::Initialization:: *)
Clear@joinable
joinable[manevrres1_?manevrQ,manevrres2_?manevrQ]:=tStart[manevrres2]==tFinal[manevrres1]
joinable[___]:=$Failed


(* ::Input::Initialization:: *)
ClearAll@joinManeuvers
joinManeuvers::domainerror="The maneuvers are not joinable. Their domains are `1` and `2`";
joinManeuvers[manevrres1_?manevrQ,manevrres2_?manevrQ]/;joinable[manevrres1,manevrres2]:=MapThread[Rule,{functionslist,joinInterpolatingFunction[{0,tFinal[manevrres1],tFinal[manevrres2]},{#/.manevrres1,#/.manevrres2}]&/@functionslist}]

joinManeuvers[manevrres1_?manevrQ,manevrres2_?manevrQ]:=($Failed; Message[joinManeuvers::domainerror,domain[manevrres1],domain[manevrres2]])

joinManeuvers[___]:=$Failed


(* ::Input::Initialization:: *)
Clear@converter
converter[V]:=3.6
converter[\[Psi]|\[Theta]]:=1/Degree
converter[_]:=1


(* ::Input::Initialization:: *)
Clear@units
units[V]:="kph"
units[\[Psi]|\[Theta]]:="\[Degree]"
units[_]:="m"


(* ::Input::Initialization:: *)
Clear@plot
plot[{fun_,domain_,label_,converter_}]:=Plot[converter fun[t],Prepend[domain,t],Frame->True,GridLines->Automatic,FrameLabel->{"t, s",label},RotateLabel->False,LabelStyle->Directive[Bold],PlotStyle->Thick]

Clear@plots
plots[manevrresult_?manevrQ]:=plot/@
({#/.manevrresult,domain[manevrresult],(ToString@#)<>", "<>units[#],converter[#]}&/@functionslist)



