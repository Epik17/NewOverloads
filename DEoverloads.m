(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
Get[NotebookDirectory[]<>"equations.m"]
Get[NotebookDirectory[]<>"pk_ErrorChecking.m"]
Get[NotebookDirectory[]<>"plots.m"]


(* ::Input::Initialization:: *)
Clear[t,x,y,z,\[Theta],\[Psi],V,\[Gamma],nya,nxa,g]


(* ::Input::Initialization:: *)
Clear@manevrQ
manevrQ[arg_]:=MatchQ[arg,{Rule[___,InterpolatingFunction[___][___]]..}]


(* ::Input::Initialization:: *)
Clear@initialConditionsQ
initialConditionsQ[arg_]:=MatchQ[arg,{__?NumericQ}]&&Length[arg]==6


(* ::Input::Initialization:: *)
ClearAll@functionslist
functionslist:=Module[{},
ClearAll[x,y,z,\[Theta],\[Psi],V];
{x,y,z,\[Theta],\[Psi],V}
];


(* ::Input::Initialization:: *)
Clear@joinedmanevrQ
joinedmanevrQ[arg_]:=MatchQ[arg,{Rule[___,_Piecewise]..}]


(* ::Input::Initialization:: *)
ClearAll@domain
domain[intfun_InterpolatingFunction]:=First@(intfun["Domain"])
domain[intfun:InterpolatingFunction[___][targ___]]:=domain[Head@intfun]+t-targ
domain[manevrresult_?manevrQ]:=domain[manevrresult[[1,2]]]
domain[joinedmanevr_?joinedmanevrQ]:={joinedmanevr[[1,2,1,1,2,1]],joinedmanevr[[1,2,1,-1,2,3]]}
ErrorChecking`setConsistencyChecks[domain,"Valid syntax:
domain[intfun_InterpolatingFunction] or
domain[intfun:InterpolatingFunction[___][targ___] or
domain[manevrresult_?manevrQ] or
domain[joinedmanevr_?joinedmanevrQ]"]


(* ::Input::Initialization:: *)
ClearAll@tStart
tStart[manevrresult_?manevrQ]:=First@domain@manevrresult
(*ConsistencyChecked*)


(* ::Input::Initialization:: *)
ClearAll@tFinal
tFinal[manevrresult_?manevrQ]:=Last@domain@manevrresult
(*ConsistencyChecked*)


(* ::Input::Initialization:: *)
Clear@appendt
appendt::tencountered="t encountered in the list of functions' symbols was omitted";

appendt[funlist:{Except[t,_Symbol]..}]:=Module[{},
ClearAll[t];
#[t]&/@funlist]

appendt[funlist:{_Symbol..}]:=Module[{},
ClearAll[t];
Message[appendt::tencountered];
appendt@DeleteCases[funlist,t]]

ErrorChecking`setConsistencyChecks[appendt,"Functions symbols list must contain nothing but clear symbols"];


(* ::Input::Initialization:: *)
ClearAll@lastState
lastState[manevrresult_?manevrQ]:=
((appendt@functionslist)/.manevrresult)/.{t->tFinal[manevrresult]}

ErrorChecking`setConsistencyChecks[{tStart,tFinal,lastState},"Valid syntax:
tStart[manevrresult_?manevrQ]"];


(* ::Input::Initialization:: *)
ClearAll@maneuver

maneuver::usage="
Returns list of InterpolatingFunctions for x, y, z, \[Theta], \[Psi], V\n
maneuver[initialconditions_?initialConditionsQ,gammafun_,nyfun_,nxfun_,event_,t0_:0] calculates maneuver based on initial conditions; t0 (which is 0 by default) is used for correcting domains of resulting functions \n
maneuver[prevmaneuver_?manevrQ,gammafun_,nyfun_,nxfun_,event_] calculates maneuver based on previous maneuver";

maneuver[initialconditions_?initialConditionsQ,gammafun_,nyfun_,nxfun_,event_,t0_:0]:=With[
{gammafunnyfunnxfunRule={\[Gamma]->gammafun,nya->nyfun,nxa->nxfun,g->9.81}},
(First@NDSolve[
equations["Classic",initialconditions,gammafun,nyfun,nxfun]~Join~{WhenEvent[event,{"StopIntegration"}]},
appendt@functionslist,
{t,0,Infinity},
EvaluationMonitor:>{
Sow[solvefor[equations["Classic","t"],Derivative[1][\[Theta]][t]]/.gammafunnyfunnxfunRule,\[Theta]dot],
Sow[N[gammafun/Degree],gam],
Sow[N@nyfun,ny],
Sow[N@nxfun,nx],
Sow[3.6V[t],VV],
Sow[t,tt],
Sow[solvefor[equations["Classic","t"],Derivative[1][\[Psi]][t]]/.gammafunnyfunnxfunRule,\[Psi]dot]
}
])/.{(fun:InterpolatingFunction[___])[t]:>fun[t-t0]}] (* domain correction *) 

maneuver[prevmaneuver_?manevrQ,gammafun_,nyfun_,nxfun_,event_]:=(
maneuver[lastState@prevmaneuver,gammafun,nyfun,nxfun,event,tFinal@prevmaneuver])

ErrorChecking`setConsistencyChecks[maneuver,"Valid syntax:\n maneuver[initialconditions_?initialConditionsQ,gammafun_,nyfun_,nxfun_,event_,t0_:0] \n or maneuver[prevmaneuver_?manevrQ,gammafun_,nyfun_,nxfun_,event_]"]


(* ::Input::Initialization:: *)
Clear@converter
converter[V]:=3.6
converter[\[Psi]|\[Theta]]:=1/Degree
converter[_]:=1


(* ::Input::Initialization:: *)
Clear@units
units[V]:="kph"
units[\[Psi]|\[Theta]]:="\[Degree]"
units[_]:="m"


(* ::Input::Initialization:: *)
Clear@domainQ
domainQ[{x_?NumericQ,y_?NumericQ}]:=y>x
domainQ[___]:=False


(* ::Input::Initialization:: *)
ClearAll@plot
plot[{fun_,domain_?domainQ,label_String,converter_?NumericQ}]:=myPlot[converter fun,Prepend[domain,t],PlotLabel->label,LabelStyle->{Directive[Black,Bold],10}](*Plot[converter fun,Prepend[domain,t],Frame\[Rule]True,GridLines\[Rule]Automatic,PlotLabel\[Rule]label,RotateLabel\[Rule]False,LabelStyle\[Rule]Directive[Bold],PlotStyle\[Rule]Thick,PlotRange\[Rule]Full]*)

ErrorChecking`setConsistencyChecks[plot,"Valid syntax:\n plot[{fun_Interpolating,domain_,label_,converter_}]"];

ClearAll@plots
plots::internalerror="Some plots have invalid format";
plots[arg_?(joinedmanevrQ[#]||manevrQ[#]&)]:=Module[
{result=plot/@
({#[t]/.arg,domain[arg],(ToString@#)<>", "<>units[#],converter[#]}&/@functionslist)},
If[Not@MemberQ[result,$Failed],result,(Message[plots::internalerror];$Failed)]
]

ErrorChecking`setConsistencyChecks[plots,"Valid syntax:\n plots[arg_?(joinedmanevrQ[#]||manevrQ[#]&)]"];


(* ::Input::Initialization:: *)
ClearAll@trajectoryPlot

trajectoryPlot[funs_List,range_]:=ParametricPlot3D[funs,range,PlotRange->Full,AxesLabel->{"x","y","z"},PlotStyle->Thickness[0.0075]]

trajectoryPlot[arg_?(joinedmanevrQ[#]||manevrQ[#]&)]:=trajectoryPlot[(appendt@{x,y,z})/.arg,Prepend[domain@arg,t]]

ErrorChecking`setConsistencyChecks[trajectoryPlot,"Valid syntax:\n trajectoryPlot[arg_?(joinedmanevrQ[#]||manevrQ[#]&)] or
trajectoryPlot[funs_List,range_]"];


(* ::Input::Initialization:: *)
ClearAll@inequality
inequality[domain_List]/;Length[domain]==2:=First@domain<=t<=Last@domain
inequality[___]:=$Failed


(* ::Input::Initialization:: *)
ClearAll@join
join[args:{InterpolatingFunction[___][___]..}]:=Piecewise[MapThread[List,{#&/@args,inequality/@(domain/@args)}]]

join[args_?manevrQ (* \:0432 \:0434\:0430\:043d\:043d\:043e\:043c \:0441\:043b\:0443\:0447\:0430\:0435, \:044d\:0442\:043e \:043d\:0435 \:043c\:0430\:043d\:0435\:0432\:0440, \:0430 \:0441\:043f\:0438\:0441\:043e\:043a \:043e\:0434\:043d\:043e\:0438\:043c\:0435\:043d\:043d\:044b\:0445 \:0438\:043d\:0442\:0435\:0440\:043f\:043e\:043b\:0438\:0440\:0443\:044e\:0449\:0438\:0445 \:0444\:0443\:043d\:043a\:0446\:0438\:0439 \:043e\:0442 \:043d\:0435\:0441\:043a\:043e\:043b\:044c\:043a\:0438\:0445 \:043c\:0430\:043d\:0435\:0432\:0440\:043e\:0432*)]:=args[[1,1]]->join[args[[All,2]]]

join[args_:{_?manevrQ..}]:=join/@Transpose[args]

join[___]:=$Failed


(* ::Input::Initialization:: *)
ClearAll[idetails,details]
SetAttributes[idetails,HoldFirst]
SetAttributes[details,HoldFirst]

idetails[man_,tags_]:=ReleaseHold[Flatten[(Reap[man;,tags])[[2]],1]]
details[man_maneuver,Optional[tags_,{tt,\[Theta]dot,\[Psi]dot,gam,ny,nx,VV}]]:=With[{completedtags=DeleteDuplicates@Prepend[tags,tt]},ReleaseHold[TableForm[Sort[{completedtags}~Join~Transpose[idetails[man,completedtags]],#1[[1]]<#2[[1]]&]]]]

ErrorChecking`setConsistencyChecks[details,"First argument must be an unevaluated maneuver: maneuver[initconds,gammafun,nyfun,nxfun,event]"];



