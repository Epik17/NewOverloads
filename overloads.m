(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
mps=3.6;


(* ::Input::Initialization:: *)
ClearAll@correctVQ
correctVQ::verror="Velocity of `1` has to belong to the interval from 0 to `2` kph. Input velocity is `3` kph";
correctVQ[helicopter_?helicopterQ,V_?NumericQ]:=If[0<=V*mps<=helicopter["Vmax"],True,(Message[correctVQ::verror,helicopter["Type"],helicopter["Vmax"],Round[V*mps,0.001]];False)]
correctVQ[___]:=False


(* ::Input::Initialization:: *)
ClearAll@correctTQ
correctTQ::tError="Temperature interval is from -40 to 40\[Degree]C. Input temperature is `1`\[Degree]C";
correctTQ[temp_?NumericQ]:=If[-40<=temp<=40,True,(Message[correctTQ::tError,Round[temp,0.001]];False)]
correctTQ[___]:=False


(* ::Input::Initialization:: *)
ClearAll@greaterThanZero
greaterThanZero::valueerror="`1` have to be greater or equal to zero. Your unput: `2`";
greaterThanZero[arg_,name_]:=If[arg>=0,True,(Message[greaterThanZero::valueerror,name,arg];False)]
greaterThanZero[arg___]:=False


(* ::Input::Initialization:: *)
ClearAll@allGood
allGood[helicopter_?helicopterQ,V_]:=correctVQ[helicopter,V]

allGood[helicopter_?helicopterQ,V_,G_,temp_]:=AllTrue[{correctVQ[helicopter,V],greaterThanZero[G,"G"],correctTQ[temp]},#==True&]

allGood[helicopter_?helicopterQ,V_,G_,temp_,H_]:=AllTrue[{correctVQ[helicopter,V],greaterThanZero[G,"G"],correctTQ[temp],greaterThanZero[H,"H"]},#==True&]

allGood::nyerror="For `1` in the given conditions ny cannot be greater than `2`. Inpit value is `3`";

allGood[helicopter_?helicopterQ,V_,G_,temp_,H_,ny_]:=AllTrue[{correctVQ[helicopter,V],greaterThanZero[G,"G"],correctTQ[temp],greaterThanZero[H,"H"],If[ny<=nyAvaliable[helicopter,G,temp,H,V],True,(Message[allGood::nyerror,helicopter["Type"],Round[nyAvaliable[helicopter,G,temp,H,V],0.001],ny];False)]},#==True&]

allGood[___]:=False


(* ::Input::Initialization:: *)
ClearAll@diapason
diapason::verror="Velocity of `1` has to belong to the the interval from 0 to `2` kph. Input velocity is `3` kph";
diapason[helicopter_?helicopterQ,V_]:=Module[{allgood},

(*If[allGood[helicopter,V],*)
helicopter["Hdyn"]-(V*mps-helicopter["ParabolaCoeff"]*helicopter["Vmax"])^2*(helicopter["Hdyn"]-helicopter["Hst"])/(helicopter["ParabolaCoeff"]*helicopter["Vmax"])^2(*,$Failed]*)]

diapason[helicopter_?helicopterQ,G_?NumericQ,temp_?NumericQ,V_]:=Module[
{normT=15,groundT,T,dH,H1,allgood},

(*If[allGood[helicopter,V,G,temp],*)

H1=diapason[helicopter,0];
groundT=helicopter["TraspUZemli"];
T=(groundT-H1*helicopter["ctgTotH"])*(G/helicopter["Gnorm"]);If[temp>normT, groundT=groundT-helicopter["TemperCoeff"]*(temp-normT)];
dH=(groundT-T)/helicopter["ctgTotH"]-H1;
diapason[helicopter,V]+dH(*,$Failed]*)
]

ErrorChecking`setConsistencyChecks[diapason,"Your input has to be diapason[helicopter_?helicopterQ,V_?NumericQ] or diapason[helicopter_?helicopterQ,G_?NumericQ,temp_?NumericQ,V_?NumericQ]"];


(* ::Input::Initialization:: *)
ClearAll@nyAvaliable
nyAvaliable::denominatorerror="Can't calculate avaliable ny";
nyAvaliable[helicopter_?helicopterQ,G_?NumericQ,temp_?NumericQ,H_,V_]:=Module[

{allgood,denominator},

(*If[allGood[helicopter,V,G,temp,H],*)

denominator=helicopter["TraspUZemli"]/helicopter["ctgTotH"]-diapason[helicopter,G,temp,V];

(*If[Abs[denominator]>0.00001,*)(helicopter["TraspUZemli"]/helicopter["ctgTotH"]-H)/denominator(*,(Message[nyAvaliable::denominatorerror];$Failed)]*)(*,

Print["FUCK"];$Failed]*)
]

ErrorChecking`setConsistencyChecks[nyAvaliable,"Your input has to be nyAvaliable[helicopter_?helicopterQ,G_?NumericQ,temp_?NumericQ,H_,V_]"];


(* ::Input::Initialization:: *)
ClearAll@airDensity
airDensity[H_]:=If[greaterThanZero[H,"H"],0.125*(20-H/1000)/(20+H/1000)]
ErrorChecking`setConsistencyChecks[airDensity,"Your input has to be airDensity[H_]"];


(* ::Input::Initialization:: *)
ClearAll@nxAvaliable
nxAvaliable::Verror="Velocity has to be greater than zero. Encountered value: `1` mps";
nxAvaliable[helicopter_?helicopterQ,ny_,G_,temp_,hManevraCurrent_,V_,Optional[Vy_,0]]:=Module[{tempV,Cx=0.0115},
(*If[V>0,
If[allGood[helicopter,V,G,temp,hManevraCurrent,ny],*)
tempV:=3.6*V;
(540/helicopter["Gnorm"])*((helicopter["TraspUZemli"]*(1-ny)/helicopter["ctgTotH"]+diapason[helicopter,G,temp,V]*ny-hManevraCurrent)*helicopter["ctgNotH"]-0.0066*G*Vy(*/2*))/tempV-Cx*helicopter["Fomet"]*airDensity[hManevraCurrent]*V^2/2/G(*,$Failed],(Message[nxAvaliable::Verror,V];$Failed)]*)]
ErrorChecking`setConsistencyChecks[nxAvaliable,"Your input has to be nxAvaliable[helicopter_?helicopterQ,ny_,G_,temp_,hManevraCurrent_,V_,Optional[Vy_,0]]"];



